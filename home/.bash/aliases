#!/usr/bin/env bash

# re-source all the files again (for when you change an alias etc.)
# NOTE: this won't remove aliases that no longer exist, but it will overwrite.
rsbash()
{
    local currHist="$HISTFILE"
    source ~/.bashrc
    continuehistory "$currHist"
}

# always colour ls
alias ls="ls --color"

# ruby with terminal fix
alias irb="irb --noreadline"

# run a fake smtp server in the command line, spitting out the results to stdout
# (point SmtpClients at 127.0.0.1).
alias fsmtp="python -m smtpd -c DebuggingServer -n localhost:25"

# windows versions mapped to bash
alias cls="clear"
alias dir="ls"

# I clear a lot after 'q'ing out of git diff'ing and then scrolling up... so I
# end up hitting q more than once, and then typing cls...
alias qcls="clear"
alias qqcls="clear"
alias qqcls="clear"
alias qqqcls="clear"
alias qqqqcls="clear"

alias listvars="showvars"

settitle()
{
    echo -e "\033]0;$1\007"
}

showvars()
{
    ( set -o posix ; set ) | less
}

vs()
{
    # default to current directory
    path="${1:-.}"
    verbose=$2

    # Ghetto path expansion (chop up alias, if it exists)
    if [[ ! -z "$1" && ! -d "$path" ]]; then
        aliasResult=$(alias "$1" 2>/dev/null)
        if [[ $? -eq 0 ]]; then
            aliasedPath=${aliasResult#*cd }
            aliasedPath=${aliasedPath%\'}

            # overwrite the argument if the choppy resulted in a valid directory
            # otherwise, try use the original argument as a path
            if [[ -d "$aliasedPath" ]]; then
                path="$aliasedPath"
            fi
        fi
    fi

    if [[ ! -z "$1" && ! ( -d "$path" || -f "$path" ) ]]; then
        echo "$path is not a valid path"
        return 1
    fi

    # find solution files in current directory
    IFS=$'\n' solutions=($(find "$path" -maxdepth 1 -type f -name '*.sln'))

    # tries two layers deep (<path>/*.sln and <path>/*/*.sln)
    # this is for directories that embed everything in a "src" folder or similar.
    if [ ${#solutions[@]} -eq 0 ]; then
        IFS=$'\n' solutions=($(find "$path" -maxdepth 2 -type f -name '*.sln'))
    fi

    if [ ${#solutions[@]} -ne 1 ]; then
        echo "Can't find unique '.sln'";
        for sln in "${solutions[@]}"
        do
            echo "\"$sln\""
        done
        return 1
    else
        echo "starting ${solutions[0]}"
        if Test-VisualStudioSolution.ps1 -Path ${solutions[0]} $verbose; then
            start ${solutions[0]}
        fi
    fi
}

# source the local aliases if there are any
# These will take precedence over anything defined above
[ -f "$HOME/.local_aliases" ] && source "$HOME/.local_aliases"
